from typing import List

import gurobipy as gp
import numpy as np
from gurobipy import GRB


def get_model(wells: List[dict], avoid_infeasible=True, q_gl_max=300000, verbose=False):
    N = list(range(len(wells)))
    M = [0,]  # manifolds

    bsw_n = [well['bsw'] for well in wells]
    gor_n = [well['gor'] for well in wells]

    # piecewise linearized q_liq (eq. (1))
    Q_LIQ_N_FUN = [well['curve'] for well in wells]
    C = [np.linspace(10, 80, 6),] * len(wells)      # whp
    GL = [np.linspace(0, 300000, 6),] * len(wells)  # q_gl

    # values not generated by the model (infeasible) are set as -1
    for n in N:
        expected_keys = [(c, gl) for c in C[n] for gl in GL[n]]
        for key in expected_keys:
            if key not in Q_LIQ_N_FUN[n]:
                Q_LIQ_N_FUN[n][key] = -1


    # Create a new model
    model = gp.Model("flow_splitting")
    if not verbose:
        model.setParam("LogToConsole", 0)

    # Create variables
    ckp_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="ckp_n")
    q_oil_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="q_oil_n")
    q_water_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="q_water_n")
    q_gas_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="q_gas_n")
    q_gl_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="q_gl_n")
    q_liq_n = model.addVars(N, vtype=GRB.CONTINUOUS, name="q_liq_n")

    # Indexing sets
    theta_n_c_gl_index = [(n, c, gl) for n in N for c in C[n] for gl in GL[n]]
    theta_n_c_gl = model.addVars(theta_n_c_gl_index, lb=0.0, vtype=GRB.CONTINUOUS, name='lmbd_n_c_gl')

    eta_n_c_index = [(n, c) for n in N for c in C[n]]
    eta_n_c = model.addVars(eta_n_c_index, vtype=GRB.CONTINUOUS, name='eta_n_c')

    eta_n_gl_index = [(n, gl) for n in N for gl in GL[n]]
    eta_n_gl = model.addVars(eta_n_gl_index, lb=0.0, vtype=GRB.CONTINUOUS, name='eta_n_gl')

    # PRODUÇÃO DOS POÇOS
    for n in N:
        model.addConstr(q_gl_n[n] == gp.quicksum(theta_n_c_gl[n, c, gl] * gl for c in C[n] for gl in GL[n]))  # eq. (2a)
        model.addConstr(ckp_n[n] == gp.quicksum(theta_n_c_gl[n, c, gl] * c for c in C[n] for gl in GL[n]))  # eq. (2b)
        model.addConstr(q_liq_n[n] == gp.quicksum(theta_n_c_gl[n, c, gl] * Q_LIQ_N_FUN[n][c, gl] for c in C[n] for gl in GL[n]))  # eq. (2c)

        model.addConstr(q_gl_n[n] <= q_gl_max)  # eq. (5)

    for n in N:
        for ckp in C[n]:
            for gl in GL[n]:
                if avoid_infeasible:
                    # constraint model not to use infeasible operation points
                    if Q_LIQ_N_FUN[n][ckp, gl] == -1:
                        model.addConstr(theta_n_c_gl[n, ckp, gl] <= 0)
                    else:
                        model.addConstr(theta_n_c_gl[n, ckp, gl] <= 1e6)

        for gl in GL[n]:
            model.addConstr(eta_n_gl[n, gl] == gp.quicksum(theta_n_c_gl[n, c, gl] for c in C[n]))  # eq. (3a)
        for ckp in C[n]:
            model.addConstr(eta_n_c[n, ckp] == gp.quicksum(theta_n_c_gl[n, ckp, gl] for gl in GL[n]))  # eq. (3b)

        # eq. (3c)
        model.addSOS(GRB.SOS_TYPE2, [eta_n_gl[n, gl] for gl in GL[n]])
        model.addConstr(gp.quicksum(eta_n_gl[n, gl] for gl in GL[n]) == 1.0)

        # eq. (3d)
        model.addSOS(GRB.SOS_TYPE2, [eta_n_c[n, c] for c in C[n]])
        model.addConstr(gp.quicksum(eta_n_c[n, c] for c in C[n]) == 1.0)

    for n in N:
        model.addConstr(q_oil_n[n] == q_liq_n[n] * (1 - bsw_n[n]))  # eq. (4a)
        model.addConstr(q_water_n[n] == q_liq_n[n] * bsw_n[n])  # eq. (4b)
        model.addConstr(q_gas_n[n] == q_liq_n[n] * (1 - bsw_n[n]) * gor_n[n])  # eq. (4c)

    ## Set objective
    model.setObjective(gp.quicksum(q_oil_n[n] for n in N), GRB.MAXIMIZE)

    model.setParam("IntFeasTol", 1e-9)
    # model.setParam("TimeLimit", 300)

    model.update()

    return model

def fix_c_gl(model, cs, gls):
    assert len(cs) <= 2
    assert len(gls) <= 2

    model_ = model.copy()

    cs = [float(c) for c in cs]
    gls = [float(gl) for gl in gls]

    for var in model_.getVars():
        if var.VarName.startswith('eta_n_c'):
            c = float(var.VarName.split(',')[-1].rstrip(']'))
            if c not in cs:
                var.ub = 0.0
        elif var.VarName.startswith('eta_n_gl'):
            gl = float(var.VarName.split(',')[-1].rstrip(']'))
            if gl not in gls:
                var.ub = 0.0

    model_.update()

    return model_

def get_C_GL(well):
    C = np.linspace(10, 80, 6)
    GL = np.linspace(0, 300000, 6)

    return C, GL

def encode_fixing(c_pair, gl_pair, well):
    C, GL = get_C_GL(well)

    c_mbd = np.zeros(len(C) - 1)

    for i in range(len(c_mbd)):
        if c_pair[0] == C[i]:
            assert c_pair[1] == C[i+1]

            c_mbd[i] = 1

    gl_mbd = np.zeros(len(GL) - 1)

    for i in range(len(gl_mbd)):
        if gl_pair[0] == GL[i]:
            assert gl_pair[1] == GL[i+1]

            gl_mbd[i] = 1
    
    return c_mbd, gl_mbd

def decode_fixing(c_mbd, gl_mbd, well):
    C, GL = get_C_GL(well)

    c_ = np.pad(c_mbd, (0,1))
    c_ += np.roll(c_, 1)

    gl_ = np.pad(gl_mbd, (0,1))
    gl_ += np.roll(gl_, 1)

    c_pair = C[c_ > 0]
    gl_pair = GL[gl_ > 0]

    return tuple(c_pair), tuple(gl_pair)
